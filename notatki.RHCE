* NSA recommendations:
  - less software == the better
  - central firewall + local firewalls
  - policy DROP for all chains
* /proc/sys/net/ipv4/ip_forward, net.ipv4.ip_forward
* xinetd:
  - access restrictions: only_from, no_access
* tcp wrappers:
  - check whether libwrap library is linked to the binary
  - /etc/hosts.{allow,deny} - allow has higher priority, default means allow
  - man hosts_access
  - example syntax:
    ALL: .vespian.net EXCEPT 1.2.3.4
    sshd: 12.4.2.0/255.255.255.0
    ALL EXCEPT sshd: 10.0.0.1
    ALL: ALL
  - the name of the binary matters, even if running through xinetd
  - when permitting some host make sure that you deny all other in hosts.deny
* rpmconfig - tool to merge all the *.rpmsave files
* iptables can translate domain names!
  iptables -A INPUT -s youtube.com -j REJECT
  -A INPUT -s 173.194.112.167/32 -j REJECT --reject-with icmp-port-unreachable
  -A INPUT -s 173.194.112.161/32 -j REJECT --reject-with icmp-port-unreachable
  etc...
* pam has excellent HTML doc -> /usr/share/doc/pam-*/html/
* pam_listfile can be used to limit per-user access. Check vsftpd pam access
  module
* SHA-1 is being phased out, SHA-2 includes four hash functions with message
  digests of up to 512 bits (SHA-512)
* man -k != apropos. apropos is case-sensitive
* while defining file context, remember to use wildcards !
  semanage fcontext -a -t httpd_sys_content_t "/web(/.*)?"
* ssh-copy-id -> tool to automatically propagate user identities (ssh-keys,
  .ssh directories, etc...)
* how RSA works:
    Choose two distinct prime numbers, such as
        p = 61 and q = 53
    Compute n = pq giving
        n = 61 * 53 = 3233
    Compute the totient of the product as φ(n) = (p − 1)(q − 1) giving
        φ(3233) = (61 - 1)(53 - 1) = 3120
    Choose any number 1 < e < 3120 that is coprime to 3120. Choosing a prime
    number for e leaves us only to check that e is not a divisor of 3120.
        Let e = 17
    Compute d, the modular multiplicative inverse of e (mod φ(n)) yielding
        d = 2753
    The public key is (n = 3233, e = 17). For a padded plaintext message m,
    the encryption function is
        c(m) = m^17 mod(3233)
    The private key is (n = 3233, d = 2753). For an encrypted ciphertext c,
    the decryption function is
        m(c) = c^2753 mod(3233)
    For instance, in order to encrypt m = 65, we calculate
        c = 65^17 mod(3233) = 2790
    To decrypt c = 2790, we calculate
        m = 2790^2753 mod(3233) = 65
* letter 'p' in the name of the openssh package/binary means that the portabi-
  - lity goop was added. OpenSSH core is developed clearly for OpenBSD.
* for SSH, asymmetric encryption is only used to share the secret key, which
  will be used for symmetric encryption
* SSHv2 session establishment:
  - sshv2 operates in 3 distinte layers:
    % transport layer - provides encrypted pipe for upper pipes, capable of
                        reliably and securely tranfer plaintext data from upper
                        layers.
    % authentication layer - takes care of authenticating the user (challege-
                             response authentication, pubkey authentication,
                             etc...)
    % connection layer - is capable of multiplexing any number of independent
                         secure sessions over a single authentication layer
  - transport layer establishement:
    % TCP connection is established
    % protocol and software versions are exchanged/verified
    % server advertises its supported protocol version and software version:
      SSH-2.0-OpenSSH_5.3
      ...
    % client advertises its supported protocol version and software as well:
      SSH-2.0-OpenSSH_6.4
      ...
    % both parties switch to binary protocol
    % the list of supported encryption protocols is presented by the client
    % server responds with the list of the algorithms it is willing to accept
      (???)
    % In case when Diffie–Hellman key exchange was choosen, booth hosts
      participate in defining session key, so that it is not exchanged via
      insecure channel.
    % the server presents its identity to the client (host key), client checks
      its signature with the one stored in known_hosts file
  - authentication layer establishment - the client authenticates itself to the
    server. It can be either pubkey auth or a pre-shared key (password auth)
  - connection layer setup - X11 forwarding, terminal, port forwarding, etc..
* ssh-copy-id -> installs public keys on the remote machine, creating .ssh
  directories if necessary
* GatewayPorts -> allows remote hosts to connect to ports forwarded by the sshd
* Limiting access to ssh on per-user basis:
  AllowUsers usr1 usr2
  AllowUsers usr1@1.2.3.4 usr2@2.3.4.5
  AllowGroups, DenyUsers, DenyGroups
* Limiting access to ssh on per-host basis - iptables, or TCPWrappers
* loading modules on boot should be done by /etc/rc.modules instead of
  /etc/rc.local. It is executed much earlier in the boot process.
  echo modprobe nf_conntrack_ftp >> /etc/rc.modules
  chmod a+x /etc/rc.modules
* semanage fcontext -l -C -> a way to find customized file contexts on a host
* selinux-policy-doc -> this package contains extra selinux policy documentation
  , i.e. detailed info on selinux booleans
* yum repolist all -> list ALL repositories, disabled included
* yum --disablerepo '*' --enablerepo  'rpmfusion-nonfree' list available ->
  list available packages from given repo
* install all optional packages with yum:
  yum --setopt=group_package_types=optional groupinstall "Your Package Group"
* yum list installed | grep @repo-id -> list packages installed from given repo
* Centos no longer ships with SRPMs in their repos, one needs to set up
  Centos-Vault repo
* semanage permissive -a ssh_t -> make just one module work in permissive mode,
  everything else is still enforcing
* semanage port -l  -> selinux defines allowed set of ports for applications
    semanage port -l | grep http
    semanage port -a -p tcp -t http_port_t 123
* ausearch -> a convinient tool to search/grep audit logs
* column -t -> arrange output into collumns
* TLS was originally developed by Netscape as SSL, but as it lost its market
  share, its mainenance was taken over by IETF and it was renamed to TLS
  (Transport Layer Security)
* TLS negotiation:
  - TCP connect (SYN/SYN+ACK/ACK)
  - client -> server ("Client Hello"):
    % SNI server identification
    % supported cipher suites, ordered by client preference
    % session ID - if the server still has negotiated session keys, then the
      expensive asymetric cryptography can be avoided. Session ID is provided
      by the server.
  - server -> client ("Server Hello"):
    % session ID - stored by the client in case it wants to reconnect
    % selected cipher from those supported by the client
  - server -> client ("Certificate")
    % provides a certificate/certificate chain (up to self-signed root CA)
  - server -> client ("Hello Done")
    % indicates that the server will not be asking client for certificates
  ---- the rest depends on chosen encryption algorithm:
  - client sends a pre-master key encrypted with server's public key
  - server sends back salted master key
  - session starts to be encrypted using calculated keys
* these are equivalent:
  if test -x /etc/something;
  if [ -x /etc/something ]
* rpmbuild -bb/-ba -> bild only binary or binary and source packages
* rpm package building:
  - never build as a root user
  - take some src package as an example
  - create directory ProgramName-X.XX
  - create empty configure script or simply remove the %configure macro
  - move the required file to the created directory
  - compress dir -> ProgramName-X.XX.tar.bz2
  - rpmdev-setuptree
  - tar.bz2 ->  rpmbuild/SOURCES
  - rpmdev-newspec programname
  - %setup - its a macro intented to uncompress tar archive in the
    rpmbuild/SOURCES directory
  - Groups: -> less /usr/share/doc/rpm-*/GROUPS
  - +BuildArch: noarch
  - comment out unneded
  - use install command in the %install section
  - %files section contains all the files owned by the package, use %dir
    keyword to list directories
  - rpmlint can give you hints on what is wrong
* static routes handling in RHEL:
  - DISABLE NETWORK MANAGER!
  - grep route- /usr/share/doc/initscripts-9.03.40/*
  - /etc/sysconfig/network-scripts/route-ethXX have two file formats:
    % old/simple:
        ADDRESS0=
        NETMASK0=
        GATEWAY0=
    % iproute2:
        default via 172.17.0.1 dev eth0
    % order of default root parsing is:
        /etc/sysconfig/network
        /etc/sysconfig/network-scripts/ifcfg-eth0
        /etc/sysconfig/network-scripts/ifcfg-eth1
        ...
        /etc/sysconfig/network-scripts/ifcfg-ethXX
        /etc/sysconfig/network-scripts/route-eth0
* system-config-authconfig + yum groupinstall "Directory client" -> enable
  Kerberos authentication for RHEL. Doing it on the commandline is a PITA.
  - Files of interest:
    % /etc/sssd/sssd.conf
    % /etc/pam_ldap.conf/etc/pam_ldap.conf
    % /etc/openldap/ldap.conf
    % /etc/nsswitch.conf
  - remember that machines must be synchronized!
* iSCSI:
  - initiator is a client
  - target is a shared storage on the server
  - LUN represents an individually addressable (logical) SCSI device that is
    part of a physical SCSI device (target). In an iSCSI environment, LUNs are
    essentially numbered disk drives
  - runs on TCP
  - iSCSI naming format:
    type.date_the_domain_was_taken.reversed_domain.storage_target_name
    iqn.1992-01.com.example:storage:diskarrays-sn-a8675309
* setting up system as an iscsi initiator:
  - open port 3260
  - install iscsi-initiator-utils.x86_64/iscsiadm
  - chkconfig iscsid on
  - /usr/share/doc/iscsi-initiator-utils-*/README
  - mount by UUID(device names sometimes change), add _netdev to options(so
    that system does not try to mount it before net has started), and make sure
    that iscsi daemons are started at boot
  - remember to set correct credentials (just one, not all of them or things
    will brake)
  - iscsiadm -m discovery -t sendtargets --portal 172.16.201.200
  - iscsiadm -m session -P3
  - iscsiadm -m node -p 172.17.0.100 --login
  - iscsiadm -m node -p 172.17.0.100 --logout
* null client - MTA that can only receive mail
* alternatives --config mta -> if somehow non-default postfix is installed
* authentication via cyrus-sasl (there is a README in doc/ depicting 
  all of these steps):
  - /etc/sysconfig/saslauthd (MECH=pam)
  - main.cf modifications
    % smtpd_sasl_auth_enable
    % smtpd_sasl_security_options
    % broken_sasl_auth_clients
    % smtpd_recipient_restrictions (permit_sasl_authenticated,
      permit_mynetworks, reject_unauth_destination)
  - restart postfix, saslauthd enable
* man 5 postconf -> all main.cf parameters :) Can be found in 
* remember about reloading postfix ;)
* source IP(client) restrictions:
  - /etc/postfix/access, postmap
  - smtpd_client_restrictions (permit_mynetworks, check_client_access, reject)
* encrypting AUTH PLAIN username/password:
    echo -ne '\0username\0password' | base64
* testing saslauthd authentication:
    testsaslauthd -u mailer1 -p test1234 -s smtp
* accepting mail from remote systems:
  - inet_interfaces
  - myhostname/destination/origin/domain/etc...
* relay mail through external host:
  - relayhost -> relay all non-local mail
    % dupa.pl -> relay to dupa.pl's MX records
    % [dupa.pl] -> relay to the A record of the dupa.pl domain
  - smarthost:
    % relay_domains -> relay only selected domains, overrides relayhost
    % relay_transport -> define how/where mail should be relayedqqq
    % relay_recipient_maps -> define valid users for relayed mail
* postconf -n -> show non-default values


#To do:
/usr/share/doc/postfix-2.6.6/README-Postfix-SASL-RedHat.txt

# Requirements that need more practice:
  - kebersos+ldap
  - rpm packaging

  - bash scripting
  - SELinux

# Optional:

