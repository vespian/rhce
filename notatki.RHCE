* NSA recommendations:
  - less software == the better
  - central firewall + local firewalls
  - policy DROP for all chains
* /proc/sys/net/ipv4/ip_forward, net.ipv4.ip_forward
* xinetd:
  - access restrictions: only_from, no_access
* tcp wrappers:
  - check whether libwrap library is linked to the binary
  - /etc/hosts.{allow,deny} - allow has higher priority, default means allow
  - man hosts_access
  - example syntax:
    ALL: .vespian.net EXCEPT 1.2.3.4
    sshd: 12.4.2.0/255.255.255.0
    ALL EXCEPT sshd: 10.0.0.1
    ALL: ALL
  - the name of the binary matters, even if running through xinetd
  - when permitting some host make sure that you deny all other in hosts.deny
* rpmconfig - tool to merge all the *.rpmsave files
* iptables can translate domain names!
  iptables -A INPUT -s youtube.com -j REJECT
  -A INPUT -s 173.194.112.167/32 -j REJECT --reject-with icmp-port-unreachable
  -A INPUT -s 173.194.112.161/32 -j REJECT --reject-with icmp-port-unreachable
  etc...
* pam has excellent HTML doc -> /usr/share/doc/pam-*/html/
* pam_listfile can be used to limit per-user access. Check vsftpd pam access
  module
* SHA-1 is being phased out, SHA-2 includes four hash functions with message
  digests of up to 512 bits (SHA-512)
* man -k != apropos. apropos is case-sensitive
* while defining file context, remember to use wildcards !
  semanage fcontext -a -t httpd_sys_content_t "/web(/.*)?"
* ssh-copy-id -> tool to automatically propagate user identities (ssh-keys,
  .ssh directories, etc...)
* how RSA works:
    Choose two distinct prime numbers, such as
        p = 61 and q = 53
    Compute n = pq giving
        n = 61 * 53 = 3233
    Compute the totient of the product as φ(n) = (p − 1)(q − 1) giving
        φ(3233) = (61 - 1)(53 - 1) = 3120
    Choose any number 1 < e < 3120 that is coprime to 3120. Choosing a prime
    number for e leaves us only to check that e is not a divisor of 3120.
        Let e = 17
    Compute d, the modular multiplicative inverse of e (mod φ(n)) yielding
        d = 2753
    The public key is (n = 3233, e = 17). For a padded plaintext message m,
    the encryption function is
        c(m) = m^17 mod(3233)
    The private key is (n = 3233, d = 2753). For an encrypted ciphertext c,
    the decryption function is
        m(c) = c^2753 mod(3233)
    For instance, in order to encrypt m = 65, we calculate
        c = 65^17 mod(3233) = 2790
    To decrypt c = 2790, we calculate
        m = 2790^2753 mod(3233) = 65
* letter 'p' in the name of the openssh package/binary means that the portabi-
  - lity goop was added. OpenSSH core is developed clearly for OpenBSD.
* for SSH, asymmetric encryption is only used to share the secret key, which
  will be used for symmetric encryption
* SSHv2 session establishment:
  - sshv2 operates in 3 distinte layers:
    % transport layer - provides encrypted pipe for upper pipes, capable of
                        reliably and securely tranfer plaintext data from upper
                        layers.
    % authentication layer - takes care of authenticating the user (challege-
                             response authentication, pubkey authentication,
                             etc...)
    % connection layer - is capable of multiplexing any number of independent
                         secure sessions over a single authentication layer
  - transport layer establishement:
    % TCP connection is established
    % protocol and software versions are exchanged/verified
    % server advertises its supported protocol version and software version:
      SSH-2.0-OpenSSH_5.3
      ...
    % client advertises its supported protocol version and software as well:
      SSH-2.0-OpenSSH_6.4
      ...
    % both parties switch to binary protocol
    % key exchange and channel enc. algorithms are negotiated
    % In case when Diffie–Hellman key exchange was choosen, booth hosts
      participate in defining session key, so that it is not exchanged via
      insecure channel.
    % the server presents its identity to the client (host key), client checks
      its signature with the one stored in known_hosts file
  - authentication layer establishment - the client authenticates itself to the
    server. It can be either pubkey auth or a pre-shared key (password auth)
  - connection layer setup - X11 forwarding, terminal, port forwarding, etc..
* ssh-copy-id -> installs public keys on the remote machine, creating .ssh
  directories if necessary
* GatewayPorts -> allows remote hosts to connect to ports forwarded by the sshd
* Limiting access to ssh on per-user basis:
  AllowUsers usr1 usr2
  AllowUsers usr1@1.2.3.4 usr2@2.3.4.5
  AllowGroups, DenyUsers, DenyGroups
* Limiting access to ssh on per-host basis - iptables, or TCPWrappers
* loading modules on boot should be done by /etc/rc.modules instead of
  /etc/rc.local. It is executed much earlier in the boot process.
  echo modprobe nf_conntrack_ftp >> /etc/rc.modules
  chmod a+x /etc/rc.modules
* semanage fcontext -l -C -> a way to find customized file contexts on a host
* selinux-policy-doc -> this package contains extra selinux policy documentation
  , i.e. detailed info on selinux booleans
* yum repolist all -> list ALL repositories, disabled included
* yum --disablerepo '*' --enablerepo  'rpmfusion-nonfree' list available ->
  list available packages from given repo
* install all optional packages with yum:
  yum --setopt=group_package_types=optional groupinstall "Your Package Group"
* yum list installed | grep @repo-id -> list packages installed from given repo
* Centos no longer ships with SRPMs in their repos, one needs to set up
  Centos-Vault repo
* semanage permissive -a ssh_t -> make just one module work in permissive mode,
  everything else is still enforcing
* semanage port -l  -> selinux defines allowed set of ports for applications
    semanage port -l | grep http
    semanage port -a -p tcp -t http_port_t 123
* ausearch -> a convinient tool to search/grep audit logs
* column -t -> arrange output into collumns
* TLS was originally developed by Netscape as SSL, but as it lost its market
  share, its mainenance was taken over by IETF and it was renamed to TLS
  (Transport Layer Security)
* TLS negotiation:
  - TCP connect (SYN/SYN+ACK/ACK)
  - client -> server ("Client Hello"):
    % SNI server identification
    % supported cipher suites, ordered by client preference
    % session ID - if the server still has negotiated session keys, then the
      expensive asymetric cryptography can be avoided. Session ID is provided
      by the server.
  - server -> client ("Server Hello"):
    % session ID - stored by the client in case it wants to reconnect
    % selected cipher from those supported by the client
  - server -> client ("Certificate")
    % provides a certificate/certificate chain (up to self-signed root CA)
  - server -> client ("Hello Done")
    % indicates that the server will not be asking client for certificates
  ---- the rest depends on chosen encryption algorithm:
  - client sends a pre-master key encrypted with server's public key
  - server sends back salted master key
  - session starts to be encrypted using calculated keys
* these are equivalent:
  if test -x /etc/something;
  if [ -x /etc/something ]


# Requirements that need checking:
  - SELinux
  - bash scripting
  - 
